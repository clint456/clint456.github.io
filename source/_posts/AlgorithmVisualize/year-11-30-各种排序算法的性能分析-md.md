---
title: 各种排序算法的性能分析.md
date: 2024-11-30 19:30:21
tags: [算法性能分析]
categories: Algorithm

---
| 排序算法          | 最优时间复杂度 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度       | 稳定性   |
|-------------------|----------------|-----------------|----------------|------------------|----------|
| **冒泡排序 (Bubble Sort)**    | O(n)           | O(n²)           | O(n²)           | O(1)             | 稳定     |
| **选择排序 (Selection Sort)**  | O(n²)          | O(n²)           | O(n²)           | O(1)             | 不稳定   |
| **插入排序 (Insertion Sort)**  | O(n)           | O(n²)           | O(n²)           | O(1)             | 稳定     |
| **归并排序 (Merge Sort)**     | O(n log n)     | O(n log n)      | O(n log n)      | O(n)             | 稳定     |
| **快速排序 (Quick Sort)**     | O(n log n)     | O(n log n)      | O(n²)           | O(log n)         | 不稳定   |
| **堆排序 (Heap Sort)**        | O(n log n)     | O(n log n)      | O(n log n)      | O(1)             | 不稳定   |
| **计数排序 (Counting Sort)**  | O(n + k)       | O(n + k)        | O(n + k)        | O(k)             | 稳定     |
| **桶排序 (Bucket Sort)**      | O(n + k)       | O(n + k)        | O(n²)           | O(n)             | 稳定     |
| **基数排序 (Radix Sort)**     | O(nk)          | O(nk)           | O(nk)           | O(n + k)         | 稳定     |
| **希尔排序 (Shell Sort)**     | O(n log n)     | O(n^(3/2))      | O(n²)           | O(1)             | 不稳定   |

### 各种排序算法的时间复杂度分析：

#### 1. 冒泡排序 (Bubble Sort)：
   - **最优**: O(n)，当数组已经是有序的时（通过优化的冒泡排序）。
   - **最差**: O(n²)，当数组是逆序时，需要每一轮都交换元素。
   - **空间复杂度**: O(1)，只需要常量空间。
   - **稳定性**: 稳定，两个相同的元素排序后顺序不变。
  

#### 2. 选择排序 (Selection Sort)：
   - **最优**: O(n²)，无论输入是否有序。
   - **最差**: O(n²)，无论输入是否有序。
   - **空间复杂度**: O(1)，只需要常量空间。
   - **稳定性**: 不稳定，相等元素的相对顺序可能会被改变。

#### 3. 插入排序 (Insertion Sort)：
   - **最优**: O(n)，当数组已经是有序的时。
   - **最差**: O(n²)，当数组是逆序时。
   - **空间复杂度**: O(1)，只需要常量空间。
   - **稳定性**: 稳定，两个相同的元素排序后顺序不变。

#### 4. 归并排序 (Merge Sort)：
   - **最优**: O(n log n)，无论输入如何，归并排序的时间复杂度是固定的。
   - **最差**: O(n log n)，最坏情况下也需要相同的时间。
   - **空间复杂度**: O(n)，归并排序需要额外的空间来存储合并的部分。
   - **稳定性**: 稳定，两个相同的元素排序后顺序不变。

#### 5. 快速排序 (Quick Sort)：
   - **最优**: O(n log n)，当分区比较均匀时。
   - **最差**: O(n²)，当数组已经是逆序的，选择的枢轴每次都在极端位置时。
   - **空间复杂度**: O(log n)，递归调用栈的深度。
   - **稳定性**: 不稳定，相等元素的相对顺序可能会被改变。

#### 6. 堆排序 (Heap Sort)：
   - **最优**: O(n log n)，堆排序不受数据的影响，始终是 O(n log n)。
   - **最差**: O(n log n)，即使是最坏情况也保持相同的时间复杂度。
   - **空间复杂度**: O(1)，堆排序是原地排序的。
   - **稳定性**: 不稳定，相等元素的相对顺序可能会被改变。

#### 7. 计数排序 (Counting Sort)：
   - **最优、最差、平均**: O(n + k)，其中 n 是数组的长度，k 是输入数据范围的大小。
   - **空间复杂度**: O(k)，需要额外的数组来存储每个元素的计数。
   - **稳定性**: 稳定，适用于有限的整数范围。

#### 8. 桶排序 (Bucket Sort)：
   - **最优**: O(n + k)，当输入数据分布均匀时。
   - **最差**: O(n²)，当数据不均匀分布时，桶内的排序退化为 O(n²)。
   - **空间复杂度**: O(n)，需要额外的空间来存储桶。
   - **稳定性**: 稳定，适用于均匀分布的数据。

#### 9. 基数排序 (Radix Sort)：
   - **最优、最差、平均**: O(nk)，其中 n 是数组的长度，k 是数据的位数（如十进制下的位数）。
   - **空间复杂度**: O(n + k)，需要额外的空间来存储每一位的桶。
   - **稳定性**: 稳定，两个相同的元素排序后顺序不变。

#### 10. 希尔排序 (Shell Sort)：
   - **最优**: O(n log n)，在某些情况下，使用合适的增量序列时，能达到较好的表现。
   - **最差**: O(n²)，当使用简单的增量序列时，希尔排序退化为插入排序。
   - **空间复杂度**: O(1)，只需要常量空间。
   - **稳定性**: 不稳定，相等元素的相对顺序可能会被改变。

### 总结：
- **最快的排序算法**（在一般情况下）：归并排序、快速排序、堆排序、基数排序等，都在 O(n log n) 左右。
- **适用于特定情况的排序算法**：计数排序、桶排序和基数排序，适用于具有特定限制的数据（如整数数据或分布均匀的数据）。
- **稳定的排序算法**：冒泡排序、插入排序、归并排序、计数排序、桶排序和基数排序都是稳定的。
- **原地排序算法**：选择排序、插入排序、堆排序、快速排序等不需要额外空间进行排序。