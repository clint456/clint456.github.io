---
title: 排序算法的性能分析
date: 2024-12-01 23:58:04
tags: 排序算法
categories: [数据结构]
math: true
---

以下是 **十种常见排序算法** 的性能分析表，涵盖了它们的 **时间复杂度** 和 **空间复杂度**。这些排序算法的选择依据不同的应用场景，比如数据规模、数据分布、是否要求稳定排序等。

| 排序算法                      | 最优时间复杂度 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 稳定性 | 备注                         |
| ----------------------------- | -------------- | -------------- | -------------- | ---------- | ------ | ---------------------------- |
| **冒泡排序<br>(Bubble Sort)**    | $$O(n)$$       | $$O(n²)$$          | $$O(n²)$$          | $$O(1)$$       | 稳定   | 简单，但效率低。             |
| **选择排序<br>(Selection Sort)** | $$O(n²)$$         | $$O(n²)$$          | $$O(n²)$$          | $$O(1)$$       | 不稳定 | 每次选择最小元素交换。       |
| **插入排序<br>(Insertion Sort)** | $$O(n)$$           | $$O(n²)$$          | $$O(n²)$$          | $$O(1)$$       | 稳定   | 小规模数据时非常高效。       |
| **归并排序<br>(Merge Sort)**     | $$O(n log n)$$     | $$O(n log n)$$     | $$O(n log n)$$     | $$O(n)$$       | 稳定   | 需要额外空间。               |
| **快速排序<br>(Quick Sort)**     | $$O(n log n)$$     | $$O(n log n)$$     | $$O(n²)$$          | $$O(log n)$$   | 不稳定 | 平均性能最优。               |
| **堆排序<br>(Heap Sort)**        | $$O(n log n)$$     | $$O(n log n)$$     | $$O(n log n)$$     | $$O(1)$$       | 不稳定 | 堆排序保证 O(n log n) 时间。 |
| **计数排序<br>(Counting Sort)**  | $$O(n + k)$$       | $$O(n + k)$$       | $$O(n + k)$$       | $$O(k)$$       | 稳定   | 适用于有较小范围的整数数据。 |
| **桶排序<br>(Bucket Sort)**      | $$O(n + k)$$       | $$O(n + k)$$       | $$O(n²)$$          | $$O(n)$$       | 稳定   | 适合均匀分布的数据。         |
| **基数排序<br>(Radix Sort)**     | $$O(n*k)$$         | $$O(n*k)$$         | $$O(n*k)$$         | $$O(n + k)$$   | 稳定   | 适用于较小范围的数据。       |
| **希尔排序<br>(Shell Sort)**     | $$O(n log n)$$     | $$O(n^(3/2))$$     | $$O(n²)$$          | $$O(1)$$       | 不稳定 | 基于插入排序的改进。         |

### 详细分析：

1. 冒泡排序 (Bubble Sort)：
   - **最优**: O(n)，当数组已经是有序时，只需一次遍历。
   - **最差**: O(n²)，当数组完全逆序时，需要多次交换。
   - **空间复杂度**: O(1)，不需要额外空间。
   - **稳定性**: 稳定，重复元素的顺序保持不变。
2. 选择排序 (Selection Sort)：
   - **最优、最差、平均**: O(n²)，每次都要遍历剩余元素寻找最小值。
   - **空间复杂度**: O(1)，不需要额外空间。
   - **稳定性**: 不稳定，相等元素的顺序可能会被改变。
3. 插入排序 (Insertion Sort)：
   - **最优**: O(n)，当数组已经是部分有序时，可以非常高效。
   - **最差**: O(n²)，最坏情况是数组逆序时。
   - **空间复杂度**: O(1)，不需要额外空间。
   - **稳定性**: 稳定，重复元素的顺序保持不变。
4. 归并排序 (Merge Sort)：
   - **最优、最差、平均**: O(n log n)，归并排序的时间复杂度在不同情况下都相同。
   - **空间复杂度**: O(n)，需要额外的空间来存储临时数组。
   - **稳定性**: 稳定，重复元素的顺序保持不变。
5. 快速排序 (Quick Sort)：
   - **最优、平均**: O(n log n)，分治法将数据分成较小的子数组，通常非常高效。
   - **最差**: O(n²)，当选择的枢轴很差时，分割不均匀导致退化为冒泡排序。
   - **空间复杂度**: O(log n)，递归栈的深度。
   - **稳定性**: 不稳定，相等元素的顺序可能会被改变。
6. 堆排序 (Heap Sort)：
   - **最优、最差、平均**: O(n log n)，堆排序的时间复杂度始终是 O(n log n)。
   - **空间复杂度**: O(1)，堆排序是原地排序。
   - **稳定性**: 不稳定，相等元素的顺序可能会被改变。
7. 计数排序 (Counting Sort)：
   - **最优、最差、平均**: O(n + k)，n 是元素个数，k 是数据范围大小。适用于数据范围较小的情况。
   - **空间复杂度**: O(k)，需要额外的计数数组。
   - **稳定性**: 稳定，排序过程中重复元素的顺序保持不变。
8. 桶排序 (Bucket Sort)：
   - **最优、平均**: O(n + k)，当数据分布均匀时，桶内排序的时间复杂度为 O(n/k)。
   - **最差**: O(n²)，当数据分布极不均匀时，每个桶都需要单独排序。
   - **空间复杂度**: O(n)，需要额外的空间来存储桶。
   - **稳定性**: 稳定，桶内元素排序时保持稳定性。
9. 基数排序 (Radix Sort)：
   - **最优、最差、平均**: O(nk)，n 是元素数量，k 是数据的位数（如十进制的位数）。
   - **空间复杂度**: O(n + k)，需要额外的桶空间。
   - **稳定性**: 稳定，排序过程中相同元素的顺序不变。
10. 希尔排序 (Shell Sort)：
    - **最优**: O(n log n)，某些增量序列可以使希尔排序达到较好的性能。
    - **最差**: O(n²)，如果选择不当的增量序列，希尔排序会退化为插入排序。
    - **空间复杂度**: O(1)，仅使用常量空间。
    - **稳定性**: 不稳定，相等元素的顺序可能会被改变。

### 总结：

- **快速排序** 和 **归并排序** 在大多数情况下提供了优秀的性能（O(n log n)）。
- **计数排序** 和 **桶排序** 适用于特定类型的数据，如数据范围有限或者均匀分布。
- **堆排序** 提供了稳定的 O(n log n) 时间复杂度，但不稳定。
- **冒泡排序**、**选择排序** 和 **插入排序** 是简单的排序算法，但效率较低，适用于小规模数据或数据基本有序的情况。

不同的排序算法有不同的优缺点，选择合适的算法能够根据数据的特征最大化性能。
